using System.Text.Json;

namespace AutoIoc;

/// <summary>
///     Adds your service as a transient and adds an HTTP client to the client factory.
///     If this is added to your implementation, then it'll add to your IOC like `services.AddHttpClient&lt;IFooBarService, FooBarService&gt;`.
///     If this is added to your interface, then it'll assume you're leveraging refit and add to your IOC an autogenerated class that implements your interface.
/// </summary>
[AttributeUsage(AttributeTargets.Class | AttributeTargets.Interface)]
public class HttpClientAttribute : Attribute
{
    internal readonly IEnumerable<Type> DelegatingHandlers;
    private Type? _primaryHandler;

    /// <summary>
    ///     Adds your service as a transient and adds an HTTP client to the client factory.
    ///     If this is added to your implementation, then it'll add to your IOC like `services.AddHttpClient&lt;IFooBarService, FooBarService&gt;`.
    ///     If this is added to your interface, then it'll assume you're leveraging refit and add to your IOC an autogenerated class that implements your interface.
    /// </summary>
    public HttpClientAttribute()
    {
        DelegatingHandlers = Array.Empty<Type>();
    }

    /// <summary>
    ///     Adds your service as a transient and adds an HTTP client to the client factory.
    ///     If this is added to your implementation, then it'll add to your IOC like `services.AddHttpClient&lt;IFooBarService, FooBarService&gt;`.
    ///     If this is added to your interface, then it'll assume you're leveraging refit and add to your IOC an autogenerated class that implements your interface.
    /// </summary>
    /// <param name="delegatingHandlers">Add your custom delegating handlers. Order matters.</param>
    public HttpClientAttribute(
        params Type[] delegatingHandlers
    )
    {
        DelegatingHandlers = ValidateDelegatingHandlerTypes(delegatingHandlers);
    }

    /// <summary>
    ///     Specify a primary delegating handler here of type HttpClientHandler.
    /// </summary>
    public Type? PrimaryHandler
    {
        get => _primaryHandler;
        set => _primaryHandler = ValidatePrimaryHandlerHandlerType(value);
    }

    /// <summary>
    ///     If unable to add to the IOC, and exception will be thrown, otherwise a console log will indicate that it was unable to be added.
    ///     Default: true
    /// </summary>
    public bool Required { get; set; } = true;

    /// <summary>
    ///     Provide a custom serializer if you so choose.
    /// </summary>
    public JsonSerializerOptions? JsonSerializerOptions { get; set; }

    private static IEnumerable<Type> ValidateDelegatingHandlerTypes(
        IEnumerable<Type> delegatingHandlers
    )
    {
        var dhArray = delegatingHandlers as Type[] ?? delegatingHandlers.ToArray();

        var invalid = dhArray.Where(_ => !_.IsSubclassOf(typeof(DelegatingHandler))).ToList();

        if (invalid.Any())
        {
            throw new InvalidOperationException($"HttpClientAttribute received invalid handlers: '{string.Join(", ", invalid)}'");
        }

        var nonDistinct = dhArray.GroupBy(_ => _.FullName).Where(_ => _.Count() > 1).Select(_ => _.Key).ToList();

        if (nonDistinct.Any())
        {
            throw new InvalidOperationException($"HttpClientAttribute received non-distinct handlers: '{string.Join(", ", nonDistinct)}'");
        }

        return dhArray;
    }

    private static Type? ValidatePrimaryHandlerHandlerType(
        Type? primaryHandler
    )
    {
        if (primaryHandler is null)
        {
            return null;
        }

        if (!primaryHandler.IsSubclassOf(typeof(HttpClientHandler)))
        {
            throw new ArgumentException($"The primary handler must be of type: '{nameof(HttpClientHandler)}'", nameof(primaryHandler));
        }

        return primaryHandler;
    }
}